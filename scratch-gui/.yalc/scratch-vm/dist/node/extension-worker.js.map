{"version":3,"file":"extension-worker.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAHA;AAAA;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AC1OA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AChBA;AACA;AAEA;;;;;;;;;;;ACHA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://VirtualMachine/webpack/universalModuleDefinition","webpack://VirtualMachine/./src/dispatch/shared-dispatch.js","webpack://VirtualMachine/./src/dispatch/worker-dispatch.js","webpack://VirtualMachine/./src/extension-support/argument-type.js","webpack://VirtualMachine/./src/extension-support/block-type.js","webpack://VirtualMachine/./src/extension-support/target-type.js","webpack://VirtualMachine/./src/util/log.js","webpack://VirtualMachine/external commonjs \"minilog\"","webpack://VirtualMachine/webpack/bootstrap","webpack://VirtualMachine/./src/extension-support/extension-worker.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualMachine\"] = factory();\n\telse\n\t\troot[\"VirtualMachine\"] = factory();\n})(global, () => {\nreturn ","const log = require('../util/log');\n\n/**\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\n * @property {string} service - the name of the service to be called\n * @property {string} method - the name of the method to be called\n * @property {Array|undefined} args - the arguments to be passed to the method\n */\n\n/**\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\n * @property {*} responseId - a copy of the response ID from the call which generated this response\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\n */\n\n/**\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\n * Any message to the dispatch system.\n */\n\n/**\n * The SharedDispatch class is responsible for dispatch features shared by\n * {@link CentralDispatch} and {@link WorkerDispatch}.\n */\nclass SharedDispatch {\n    constructor () {\n        /**\n         * List of callback registrations for promises waiting for a response from a call to a service on another\n         * worker. A callback registration is an array of [resolve,reject] Promise functions.\n         * Calls to local services don't enter this list.\n         * @type {Array.<Function[]>}\n         */\n        this.callbacks = [];\n\n        /**\n         * The next response ID to be used.\n         * @type {int}\n         */\n        this.nextResponseId = 0;\n    }\n\n    /**\n     * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n     * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n     * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n     * transferred to the worker, and they should not be used after this call.\n     * @example\n     *      dispatcher.call('vm', 'setData', 'cat', 42);\n     *      // this finds the worker for the 'vm' service, then on that worker calls:\n     *      vm.setData('cat', 42);\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n    call (service, method, ...args) {\n        return this.transferCall(service, method, null, ...args);\n    }\n\n    /**\n     * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n     * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n     * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n     * transferred to the worker, and they should not be used after this call.\n     * @example\n     *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);\n     *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:\n     *      vm.setData('cat', myArrayBuffer);\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n    transferCall (service, method, transfer, ...args) {\n        try {\n            const {provider, isRemote} = this._getServiceProvider(service);\n            if (provider) {\n                if (isRemote) {\n                    return this._remoteTransferCall(provider, service, method, transfer, ...args);\n                }\n\n                // TODO: verify correct `this` after switching from apply to spread\n                // eslint-disable-next-line prefer-spread\n                const result = provider[method].apply(provider, args);\n                return Promise.resolve(result);\n            }\n            return Promise.reject(new Error(`Service not found: ${service}`));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Check if a particular service lives on another worker.\n     * @param {string} service - the service to check.\n     * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.\n     * @private\n     */\n    _isRemoteService (service) {\n        return this._getServiceProvider(service).isRemote;\n    }\n\n    /**\n     * Like {@link call}, but force the call to be posted through a particular communication channel.\n     * @param {object} provider - send the call through this object's `postMessage` function.\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n    _remoteCall (provider, service, method, ...args) {\n        return this._remoteTransferCall(provider, service, method, null, ...args);\n    }\n\n    /**\n     * Like {@link transferCall}, but force the call to be posted through a particular communication channel.\n     * @param {object} provider - send the call through this object's `postMessage` function.\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n    _remoteTransferCall (provider, service, method, transfer, ...args) {\n        return new Promise((resolve, reject) => {\n            const responseId = this._storeCallbacks(resolve, reject);\n\n            /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */\n            if ((args.length > 0) && (typeof args[args.length - 1].yield === 'function')) {\n                args.pop();\n            }\n\n            if (transfer) {\n                provider.postMessage({service, method, responseId, args}, transfer);\n            } else {\n                provider.postMessage({service, method, responseId, args});\n            }\n        });\n    }\n\n    /**\n     * Store callback functions pending a response message.\n     * @param {Function} resolve - function to call if the service method returns.\n     * @param {Function} reject - function to call if the service method throws.\n     * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.\n     * @protected\n     */\n    _storeCallbacks (resolve, reject) {\n        const responseId = this.nextResponseId++;\n        this.callbacks[responseId] = [resolve, reject];\n        return responseId;\n    }\n\n    /**\n     * Deliver call response from a worker. This should only be called as the result of a message from a worker.\n     * @param {int} responseId - the response ID of the callback set to call.\n     * @param {DispatchResponseMessage} message - the message containing the response value(s).\n     * @protected\n     */\n    _deliverResponse (responseId, message) {\n        try {\n            const [resolve, reject] = this.callbacks[responseId];\n            delete this.callbacks[responseId];\n            if (message.error) {\n                reject(message.error);\n            } else {\n                resolve(message.result);\n            }\n        } catch (e) {\n            log.error(`Dispatch callback failed: ${JSON.stringify(e)}`);\n        }\n    }\n\n    /**\n     * Handle a message event received from a connected worker.\n     * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.\n     * @param {MessageEvent} event - the message event to be handled.\n     * @protected\n     */\n    _onMessage (worker, event) {\n        /** @type {DispatchMessage} */\n        const message = event.data;\n        message.args = message.args || [];\n        let promise;\n        if (message.service) {\n            if (message.service === 'dispatch') {\n                promise = this._onDispatchMessage(worker, message);\n            } else {\n                promise = this.call(message.service, message.method, ...message.args);\n            }\n        } else if (typeof message.responseId === 'undefined') {\n            log.error(`Dispatch caught malformed message from a worker: ${JSON.stringify(event)}`);\n        } else {\n            this._deliverResponse(message.responseId, message);\n        }\n        if (promise) {\n            if (typeof message.responseId === 'undefined') {\n                log.error(`Dispatch message missing required response ID: ${JSON.stringify(event)}`);\n            } else {\n                promise.then(\n                    result => worker.postMessage({responseId: message.responseId, result}),\n                    error => worker.postMessage({responseId: message.responseId, error})\n                );\n            }\n        }\n    }\n\n    /**\n     * Fetch the service provider object for a particular service name.\n     * @abstract\n     * @param {string} service - the name of the service to look up\n     * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n     * @protected\n     */\n    _getServiceProvider (service) {\n        throw new Error(`Could not get provider for ${service}: _getServiceProvider not implemented`);\n    }\n\n    /**\n     * Handle a call message sent to the dispatch service itself\n     * @abstract\n     * @param {Worker} worker - the worker which sent the message.\n     * @param {DispatchCallMessage} message - the message to be handled.\n     * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n     * @private\n     */\n    _onDispatchMessage (worker, message) {\n        throw new Error(`Unimplemented dispatch message handler cannot handle ${message.method} method`);\n    }\n}\n\nmodule.exports = SharedDispatch;\n","const SharedDispatch = require('./shared-dispatch');\n\nconst log = require('../util/log');\n\n/**\n * This class provides a Worker with the means to participate in the message dispatch system managed by CentralDispatch.\n * From any context in the messaging system, the dispatcher's \"call\" method can call any method on any \"service\"\n * provided in any participating context. The dispatch system will forward function arguments and return values across\n * worker boundaries as needed.\n * @see {CentralDispatch}\n */\nclass WorkerDispatch extends SharedDispatch {\n    constructor () {\n        super();\n\n        /**\n         * This promise will be resolved when we have successfully connected to central dispatch.\n         * @type {Promise}\n         * @see {waitForConnection}\n         * @private\n         */\n        this._connectionPromise = new Promise(resolve => {\n            this._onConnect = resolve;\n        });\n\n        /**\n         * Map of service name to local service provider.\n         * If a service is not listed here, it is assumed to be provided by another context (another Worker or the main\n         * thread).\n         * @see {setService}\n         * @type {object}\n         */\n        this.services = {};\n\n        this._onMessage = this._onMessage.bind(this, self);\n        if (typeof self !== 'undefined') {\n            self.onmessage = this._onMessage;\n        }\n    }\n\n    /**\n     * @returns {Promise} a promise which will resolve upon connection to central dispatch. If you need to make a call\n     * immediately on \"startup\" you can attach a 'then' to this promise.\n     * @example\n     *      dispatch.waitForConnection.then(() => {\n     *          dispatch.call('myService', 'hello');\n     *      })\n     */\n    get waitForConnection () {\n        return this._connectionPromise;\n    }\n\n    /**\n     * Set a local object as the global provider of the specified service.\n     * WARNING: Any method on the provider can be called from any worker within the dispatch system.\n     * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.\n     * @param {object} provider - a local object which provides this service.\n     * @returns {Promise} - a promise which will resolve once the service is registered.\n     */\n    setService (service, provider) {\n        if (Object.prototype.hasOwnProperty.call(this.services, service)) {\n            log.warn(`Worker dispatch replacing existing service provider for ${service}`);\n        }\n        this.services[service] = provider;\n        return this.waitForConnection.then(() => this._remoteCall(self, 'dispatch', 'setService', service));\n    }\n\n    /**\n     * Fetch the service provider object for a particular service name.\n     * @override\n     * @param {string} service - the name of the service to look up\n     * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n     * @protected\n     */\n    _getServiceProvider (service) {\n        // if we don't have a local service by this name, contact central dispatch by calling `postMessage` on self\n        const provider = this.services[service];\n        return {\n            provider: provider || self,\n            isRemote: !provider\n        };\n    }\n\n    /**\n     * Handle a call message sent to the dispatch service itself\n     * @override\n     * @param {Worker} worker - the worker which sent the message.\n     * @param {DispatchCallMessage} message - the message to be handled.\n     * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n     * @protected\n     */\n    _onDispatchMessage (worker, message) {\n        let promise;\n        switch (message.method) {\n        case 'handshake':\n            promise = this._onConnect();\n            break;\n        case 'terminate':\n            // Don't close until next tick, after sending confirmation back\n            setTimeout(() => self.close(), 0);\n            promise = Promise.resolve();\n            break;\n        default:\n            log.error(`Worker dispatch received message for unknown method: ${message.method}`);\n        }\n        return promise;\n    }\n}\n\nmodule.exports = new WorkerDispatch();\n","/**\n * Block argument types\n * @enum {string}\n */\nconst ArgumentType = {\n    /**\n     * Numeric value with angle picker\n     */\n    ANGLE: 'angle',\n\n    /**\n     * Boolean value with hexagonal placeholder\n     */\n    BOOLEAN: 'Boolean',\n\n    /**\n     * Numeric value with color picker\n     */\n    COLOR: 'color',\n\n    /**\n     * Numeric value with text field\n     */\n    NUMBER: 'number',\n\n    /**\n     * String value with text field\n     */\n    STRING: 'string',\n\n    /**\n     * String value with matrix field\n     */\n    MATRIX: 'matrix',\n\n    /**\n     * MIDI note number with note picker (piano) field\n     */\n    NOTE: 'note',\n\n    /**\n     * Inline image on block (as part of the label)\n     */\n    IMAGE: 'image'\n};\n\nmodule.exports = ArgumentType;\n","/**\n * Types of block\n * @enum {string}\n */\nconst BlockType = {\n    /**\n     * Boolean reporter with hexagonal shape\n     */\n    BOOLEAN: 'Boolean',\n\n    /**\n     * A button (not an actual block) for some special action, like making a variable\n     */\n    BUTTON: 'button',\n\n    /**\n     * Command block\n     */\n    COMMAND: 'command',\n\n    /**\n     * Specialized command block which may or may not run a child branch\n     * The thread continues with the next block whether or not a child branch ran.\n     */\n    CONDITIONAL: 'conditional',\n\n    /**\n     * Specialized hat block with no implementation function\n     * This stack only runs if the corresponding event is emitted by other code.\n     */\n    EVENT: 'event',\n\n    /**\n     * Hat block which conditionally starts a block stack\n     */\n    HAT: 'hat',\n\n    /**\n     * Specialized command block which may or may not run a child branch\n     * If a child branch runs, the thread evaluates the loop block again.\n     */\n    LOOP: 'loop',\n\n    /**\n     * General reporter with numeric or string value\n     */\n    REPORTER: 'reporter'\n};\n\nmodule.exports = BlockType;\n","/**\n * Default types of Target supported by the VM\n * @enum {string}\n */\nconst TargetType = {\n    /**\n     * Rendered target which can move, change costumes, etc.\n     */\n    SPRITE: 'sprite',\n\n    /**\n     * Rendered target which cannot move but can change backdrops\n     */\n    STAGE: 'stage'\n};\n\nmodule.exports = TargetType;\n","const minilog = require('minilog');\nminilog.enable();\n\nmodule.exports = minilog('vm');\n","module.exports = require(\"minilog\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/* eslint-env worker */\n\nconst ArgumentType = require('../extension-support/argument-type');\nconst BlockType = require('../extension-support/block-type');\nconst dispatch = require('../dispatch/worker-dispatch');\nconst TargetType = require('../extension-support/target-type');\n\nclass ExtensionWorker {\n    constructor () {\n        this.nextExtensionId = 0;\n\n        this.initialRegistrations = [];\n\n        dispatch.waitForConnection.then(() => {\n            dispatch.call('extensions', 'allocateWorker').then(x => {\n                const [id, extension] = x;\n                this.workerId = id;\n\n                try {\n                    importScripts(extension);\n\n                    const initialRegistrations = this.initialRegistrations;\n                    this.initialRegistrations = null;\n\n                    Promise.all(initialRegistrations).then(() => dispatch.call('extensions', 'onWorkerInit', id));\n                } catch (e) {\n                    dispatch.call('extensions', 'onWorkerInit', id, e);\n                }\n            });\n        });\n\n        this.extensions = [];\n    }\n\n    register (extensionObject) {\n        const extensionId = this.nextExtensionId++;\n        this.extensions.push(extensionObject);\n        const serviceName = `extension.${this.workerId}.${extensionId}`;\n        const promise = dispatch.setService(serviceName, extensionObject)\n            .then(() => dispatch.call('extensions', 'registerExtensionService', serviceName));\n        if (this.initialRegistrations) {\n            this.initialRegistrations.push(promise);\n        }\n        return promise;\n    }\n}\n\nglobal.Scratch = global.Scratch || {};\nglobal.Scratch.ArgumentType = ArgumentType;\nglobal.Scratch.BlockType = BlockType;\nglobal.Scratch.TargetType = TargetType;\n\n/**\n * Expose only specific parts of the worker to extensions.\n */\nconst extensionWorker = new ExtensionWorker();\nglobal.Scratch.extensions = {\n    register: extensionWorker.register.bind(extensionWorker)\n};\n"],"names":[],"sourceRoot":""}